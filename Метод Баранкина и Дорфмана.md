
> [!INFO] **Метод Баранкина и Дорфмана** предназначен для решения задач **квадратичного программирования**.

---

## Задача квадратичного программирования

Рассматривается задача квадратичного программирования вида:
$$\min \{\bar{p}^T \bar{x} + \bar{x}^T C \bar{x} | A \bar{x} \le \bar{b}, \bar{x} \ge 0\}, \quad (1)$$
в которой $C$ - положительно полуопределенная матрица размерности $n \times n$, $A$ - матрица размерности $m \times n$.

---

## Условия Куна-Таккера для задачи

Условия Куна-Таккера для задачи (1) будут иметь вид (это система из [[Теорема Куна-Таккера|Теоремы Куна-Таккера]]):
$$\begin{cases} A \bar{x} + \bar{Y} = \bar{b} \\ 2C \bar{x} - \bar{V} + A^T \bar{\lambda} = -\bar{p} \\ \bar{x} \ge 0, \bar{V} \ge 0, \bar{Y} \ge 0, \bar{\lambda} \ge 0 \end{cases} \quad (2)$$
И дополнительное условие комплементарности:
$$\bar{x}^T \bar{V} + \bar{Y}^T \bar{\lambda} = 0, \quad (3)$$
где:
*   $\bar{V} = \nabla_{\bar{x}} F(\bar{x}, \bar{\lambda}) = \bar{p} + 2C \bar{x} + A^T \bar{\lambda}$
*   $\bar{Y} = -\nabla_{\bar{\lambda}} F(\bar{x}, \bar{\lambda}) = -\bar{A}\bar{x} + \bar{b}$

> [!INFO] Условие (3) может выполняться только для допустимого базисного решения системы (2), то есть для решения, в котором самое большее $N = n+m$ переменных из всех $2N = 2(n+m)$ переменных $\bar{x} \ge 0, \bar{V} \ge 0, \bar{Y} \ge 0, \bar{\lambda} \ge 0$ системы положительны. (То есть, не более $n+m$ компонент отличны от нуля).

---

## Идея метода

Решаемая задача формулируется следующим образом: среди допустимых базисных решений системы (2) найти такое, которое обращает в нуль величину $\bar{x}^T \bar{V} + \bar{Y}^T \bar{\lambda}$.

> [!INFO] В методе Баранкина и Дорфмана начинают с некоторого базисного решения системы (2), необязательно удовлетворяющего условию (3), и с помощью симплексных преобразований сводят к нулю выпуклую функцию $\bar{x}^T \bar{V} + \bar{Y}^T \bar{\lambda}$.

---

## Алгоритм (общие шаги)

Все переменные системы (2) представим в виде $2N$-мерного вектора $\bar{z}$:
$$\bar{z}^T = (\bar{x}^T, \bar{Y}^T, \bar{V}^T, \bar{\lambda}^T).$$
И условия (2) и (3) можно записать в следующем виде:
$$\begin{cases} \begin{pmatrix} A & E & 0 & 0 \\ 2C & 0 & -E & A^T \end{pmatrix} \bar{z} = \begin{pmatrix} \bar{b} \\ -\bar{p} \end{pmatrix} \\ \bar{z} \ge 0 \end{cases} \quad (4)$$
И условие комплементарности:
$$\bar{z}^T \bar{z}^* = 0, \quad (5)$$
где $\bar{z}^*$ - вектор, соответствующий $\bar{V}, \bar{\lambda}, \bar{x}, \bar{Y}$.

Минимум $T(\bar{z}) = \bar{z}^T \bar{z}^*$ при ограничениях (4) достигается на некотором базисном решении (4) и равен нулю. Вектор $\bar{x}$, составленный из компонент $x_i$ оптимального вектора $\bar{z}^*$, является решением исходной задачи квадратичного программирования.

Работа алгоритма Баранкина и Дорфмана начинается с некоторого базисного решения системы (4) $\bar{z}^0$ с соответствующей симплексной таблицей.
Функция $T(\bar{z}) = \bar{z}^T \bar{z}^*$ минимизируется по следующему рекуррентному правилу.

### Порядок вычислений:

1.  В первую очередь получают некоторое базисное решение (например, $\bar{z}^0$).
2.  Дополняют симплексную таблицу строками для небазисных переменных, упорядочивают таблицу, строят дополнительную таблицу.
3.  Если $\alpha_0 = 0$, то таблица оптимальна и $\bar{x}$ есть решение.
4.  В противном случае отыскивают переменные $t_j$ (небазисные) для которых $\alpha_j < 0$.
5.  Для этих $t_j$ вычисляют $\beta_j$ и $K_j$.
    *   $K_j = \alpha_j + \theta_j \beta_j$.
    *   $\theta_j = \min_{g | d_{gj} < 0} \left|\frac{d_{g0}}{d_{gj}}\right|$.
6.  Выбираем столбец с минимальным по модулю отрицательным значением $\theta_j K_j$. Эту переменную включаем в базис.
7.  Элемент $d_{gj}$, по которому определили $\theta_j$, становится опорным элементом.
8.  Выполняем преобразования таблицы по правилам [[Линейное программирование#Правила выбора разрешающего элемента (ОП)|симплекс-метода]].
9.  Повторяем шаги 3-8 до достижения оптимальности.

> [!NOTE] Если все $K_j \ge 0$, а $\alpha_0 > 0$, то метод далее неприменим (невозможно перейти в другую вершину из-за увеличения $T$). В этом случае включаем в базис какую-нибудь переменную и пытаемся выйти из «мертвой зоны», либо выбираем в качестве начального другое базисное решение.

> [!INFO] Если заменяющий столбец определен, дополнительная таблица больше не нужна.
> Преобразования таблицы производятся по стандартным симплексным правилам.